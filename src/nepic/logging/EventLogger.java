package nepic.logging;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import nepic.Nepic;
import nepic.util.Verify;

/**
 * Class that logs events generated by NEPIC to a file.
 *
 * @author AJ Parmidge
 */
public class EventLogger {
    /**
     * String to use in {@link #logEvent(EventType, String, Object...)} if there is no message
     * associated with the logging event to display to the user.
     */
    public static final String LOG_ONLY = null;
    /**
     * The number of {@link Log} events that can be maintained before saving the events to the
     * current log file.
     */
    private static final int NUM_EVENTS_BEFORE_SAVE = 100; // Must be > 0.
    /**
     * The list of unsaved log events.
     */
    private final List<Log> events = new ArrayList<Log>(NUM_EVENTS_BEFORE_SAVE);
    /**
     * Whether or not an error event has been recored by this log.
     */
    private boolean errorRecorded = false;
    /**
     * The file to which this {@link EventLogger}'s log is saved.
     */
    private File logFile = null;
    /**
     * The object that writes this {@link EventLogger}'s logs to the file where it should be saved.
     */
    private PrintWriter writer = null;
    /**
     * The observer to notify when an event is logged by this {@link EventLogger}.
     */
    private LoggerObserver observer = null;

    /**
     * Creates an {@link EventLogger} that writes to a file with the given name.
     *
     * @param eventLogName the name of the log to write to. NOTE: this should NOT include the file
     *        extension of the log. The final output of the this {@link eventLogger} will be written
     *        to the file: &lt{@code eventLogName}&gt[&ltsome number&gt].log
     */
    public EventLogger(String eventLogName) {
        Verify.notNull(eventLogName, "eventLogName");

        // Set up event logging for this session
        logFile = getLogFile(eventLogName);
        if (logFile != null) {
            try {
                writer = new PrintWriter(new BufferedWriter(new FileWriter(logFile, true)));
                writer.println(makeStartingLogLine());
            } catch (IOException e) { // Fail silently.
                if (writer != null) {
                    writer.close();
                    writer = null;
                }
                logFile = null;
            }
        }
    }

    /**
     * Formats the given exception as a string that contains useful logging information (including
     * the exception name, type, message, and stack trace).
     *
     * @param e the exception to convert to a string
     * @return the string representation of the given exception
     */
    public static String formatException(Throwable e) {
        StringBuilder builder = new StringBuilder(e.toString());
        boolean includedNepicMethods = false;
        for (StackTraceElement el : e.getStackTrace()) {
            String elString = el.toString();
            if (elString.startsWith("nepic")) { // NOTE: THIS IS NEPIC-SPECIFIC (nepic packages)
                includedNepicMethods = true;
            } else if (includedNepicMethods) {
                break;
            }
            builder.append("\n\tat ");
            builder.append(elString);

        }
        return builder.toString();
    }

    /**
     * Returns whether or not events logged by this {@link EventLogger} can be saved to a file.
     */
    public boolean canSaveLog() {
        return logFile != null;
    }

    /**
     * Adds an ending line to the log, and saves all as-yet unsaved portions of the log.
     */
    public void endLog() {
        if (canSaveLog()) {
            saveLog(); // save any unsaved Log events before closing the out stream
            writer.print("# Session ended and log successfully completed at " + new Date());
            writer.flush();
            writer.close();
        }
    }

    /**
     * Returns the name of the file which holds the log for this {@link EventLogger}.
     */
    public String getLogFileName() {
        if (logFile == null) {
            return null;
        }
        return logFile.getName();
    }

    public String getLogFilePath() {
        if (logFile == null) {
            return null;
        }
        return logFile.getAbsolutePath();
    }

    /**
     * Determines whether or not errors have been recorded by this {@link EventLogger}.
     */
    public boolean isErrorRecorded() {
        return errorRecorded;
    }

    /**
     * Logs an event of the given {@link EventType} with the given message to the current log.
     *
     * @param eventType the type of this event
     * @param messageForUser the message associated with this event that should be passed to this
     *        logger's observers. If no message should be passed, this should be
     *        {@link EventLogger#LOG_ONLY}.
     * @param furtherInfo any further information about this event that should be logged, but not
     *        passed to this logger's observers and/or displayed to the user
     */
    public void logEvent(EventType eventType, String messageForUser, Object... furtherInfo) {
        Log currentEvent = new Log(eventType, messageForUser, furtherInfo);
        if (canSaveLog()) {
            events.add(currentEvent);
            if(events.size() >= NUM_EVENTS_BEFORE_SAVE){
                saveLog();
            }
        }

        // If error, record that error has occurred
        if (eventType == EventType.ERROR || eventType == EventType.FATAL_ERROR) {
            errorRecorded = true;
        }

        // Inform observer of event.
        if (observer != null && messageForUser != null) {
            switch (eventType) {
            case INFO:
                observer.respondToInfo(messageForUser);
                break;
            case WARNING:
                observer.respondToWarning(messageForUser);
                break;
            case ERROR:
                observer.respondToError(messageForUser);
                break;
            case FATAL_ERROR:
                observer.respondToFatalError(messageForUser);
                break;
            case VERBOSE: // Do nothing.
                break;
            }
        }

        if (eventType == EventType.FATAL_ERROR) { // Close NEPIC upon fatal error.
            Nepic.exit();
        }
    }

    /**
     * Sets the given {@link LoggerObserver} as the observer that this {@link EventLogger} informs
     * of events.
     *
     * @param observer the observer to set
     */
    public void setObserver(LoggerObserver observer) {
        this.observer = observer;
    }

    private File getLogFile(String name) {
        int logNum = 1;
        String logName;
        File logFile;
        boolean fileExists;
        do { // Don't write to file over 500kB
            logName = name + "[" + logNum + "].log";
            logFile = new File(logName);
            logNum++;

            fileExists = logFile.exists();
        } while (fileExists && (logFile.length() > 512000L || !logFile.canWrite()));

        // Try to make the file if it doesn't yet exist.
        if (!fileExists) {
            try {
                if (!logFile.createNewFile()) {
                    return null; // Fail silently.
                }
            } catch (IOException e) {
                return null; // Fail silently.
            }
        }

        return logFile;
    }

    private String makeStartingLogLine() {
        return new StringBuilder("\n\n*****************************************************\n\n# ")
                .append(Nepic.getName())
                .append(' ')
                .append(Nepic.getFullVersion())
                .append(" ")
                .append(this.getClass().getName())
                .append(" initialized ")
                .append(new Date())
                .toString();
    }

    private boolean saveLog() { // will only be called if have logging file
        try {
            for (Log event : events) {
                if (!event.type.equals(EventType.VERBOSE)
                        || Nepic.getPrefs().isVerboseEventLogged()) {
                    writer.println(event);
                }
            }
            events.clear();
            writer.flush();
            return true;
        } catch (Exception e) {
            Nepic.log(EventType.ERROR, "Unable to save logged events" + ": " + formatException(e));
            return false;
        }
    }

    /**
     * Class representing a single event that has been logged.
     *
     * @author AJ Parmidge
     */
    private class Log {
        private static final String separator = " ";
        private static final String usrMsgToken = "\"";
        private final EventType type;
        private String message;

        private Log(EventType type, String messageForUser, Object[] furtherInfo) {
            // initial verification
            Verify.notNull(type, "type");
            Verify.notNull(furtherInfo, "futher info");

            // Type of event being logged
            this.type = type;

            createLogMessage(messageForUser, furtherInfo);
        }

        private void createLogMessage(String messageForUser, Object[] furtherInfo) {
            StringBuilder builder = new StringBuilder(type.toString()).append(";\t");

            // Info about method generating message to be logged
            for (Object o : beginLog()) {
                builder.append(separator).append(o);
            }
            builder.append(" ::");

            // Include message to user, if necessary
            if (messageForUser != null && !messageForUser.isEmpty()) {
                builder.append(separator).append(usrMsgToken).append(messageForUser).append(
                        usrMsgToken);
            }

            // Include all given further info
            for (Object o : furtherInfo) {
                builder.append(separator).append(o);
            }

            message = builder.toString();
        }

        private Object[] beginLog() {
            StackTraceElement callerMethodInfo = Thread.currentThread().getStackTrace()[7];
            Object[] eventInfo = new Object[5];
            eventInfo[0] = callerMethodInfo.getClassName();
            eventInfo[1] = callerMethodInfo.getMethodName() + "()";
            eventInfo[2] = "[line";
            eventInfo[3] = callerMethodInfo.getLineNumber();
            eventInfo[4] = "]";
            return eventInfo;
        }

        @Override
        public String toString() {
            return message;
        }
    }
}
