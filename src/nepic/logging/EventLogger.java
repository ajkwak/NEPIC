package nepic.logging;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import nepic.Nepic;
import nepic.util.Verify;

/**
 * Class that logs events generated by NEPIC to a file.
 *
 * @author AJ Parmidge
 */
public class EventLogger {
    /**
     * String to use in {@link #logEvent(EventType, String, Object...)} if there is no message
     * associated with the logging event to display to the user.
     */
    public static final String LOG_ONLY = null;
    /**
     * The number of {@link Log} events that can be maintained before saving the events to the
     * current log file.
     */
    private static final int NUM_EVENTS_BEFORE_SAVE = 100;
    /**
     * The list of unsaved log events.
     */
    private final List<Log> events = new ArrayList<Log>(NUM_EVENTS_BEFORE_SAVE);
    /**
     * Whether or not an error event has been recored by this log.
     */
    private boolean errorRecorded = false;
    /**
     * The file to which this {@link EventLogger}'s log is saved.
     */
    private File logFile;
    /**
     * The object that writes this {@link EventLogger}'s logs to the file where it should be saved.
     */
    private PrintWriter writer = null;
    /**
     * The list of observers to notify when an event is logged by this {@link EventLogger}.
     */
    private LinkedList<LoggerObserver> observers = new LinkedList<LoggerObserver>();

    /**
     * Creates an {@link EventLogger} that writes to a file with the given name.
     *
     * @param eventLogName the name of the log to write to. NOTE: this should NOT include the file
     *        extension of the log. The final output of the this {@link eventLogger} will be written
     *        to the file: &lt{@code eventLogName}&gt[&ltsome number&gt].log
     */
    public EventLogger(String eventLogName) {
        Verify.notNull(eventLogName, "eventLogName");

        // Set up event logging for this session
        logFile = getLogFile(eventLogName);
        if (logFile != null) {
            try {
                writer = new PrintWriter(new BufferedWriter(new FileWriter(logFile, true)));
                writer.println(makeStartingLogLine());
            } catch (IOException e) {
                logFile = null;
                logEvent(EventType.ERROR,
                        "Unable to initialize log!  All log events will be displayed in their "
                                + "entirety during this session.", formatException(e));
            }
        } else {
            logEvent(EventType.ERROR,
                    "Unable to initialize log!  All log events will be displayed in their "
                            + "entirety during this session.");
        }
    }

    /**
     * Formats the given exception as a string that contains useful logging information (including
     * the exception name, type, message, and stack trace).
     *
     * @param e the exception to convert to a string
     * @return the string representation of the given exception
     */
    public static String formatException(Throwable e) {
        StringBuilder builder = new StringBuilder(e.toString());
        boolean includedNepicMethods = false;
        for (StackTraceElement el : e.getStackTrace()) {
            String elString = el.toString();
            if (elString.startsWith("nepic")) { // NOTE: THIS IS NEPIC-SPECIFIC (nepic packages)
                includedNepicMethods = true;
            } else if (includedNepicMethods) {
                break;
            }
            builder.append("\n\tat ");
            builder.append(elString);

        }
        return builder.toString();
    }

    /**
     * Returns whether or not events logged by this {@link EventLogger} can be saved to a file.
     */
    public boolean canLog() {
        return logFile != null;
    }

    /**
     * Adds an ending line to the log, and saves all as-yet unsaved portions of the log.
     */
    public void endLog() {
        if (canLog()) {
            saveLog(); // save any unsaved Log events before closing the out stream
            writer.print("# Session ended and log successfully completed at " + new Date());
            writer.flush();
            writer.close();
        }
    }

    /**
     * Returns the name of the file which holds the log for this {@link EventLogger}.
     */
    public String getLogFileName() {
        if (logFile == null) {
            return null;
        }
        return logFile.getName();
    }

    /**
     * Determines whether or not errors have been recorded by this {@link EventLogger}.
     */
    public boolean isErrorRecorded() {
        return errorRecorded;
    }

    /**
     * Logs an event of the given {@link EventType} with the given message to the current log.
     *
     * @param eventType the type of this event
     * @param messageForUser the message associated with this event that should be passed to this
     *        logger's observers. If no message should be passed, this should be
     *        {@link EventLogger#LOG_ONLY}.
     * @param furtherInfo any further information about this event that should be logged, but not
     *        passed to this logger's observers and/or displayed to the user
     * @return
     */
    public void logEvent(EventType eventType, String messageForUser, Object... furtherInfo) {
        boolean haveLoggingFile = canLog();

        if (haveLoggingFile && events.size() >= NUM_EVENTS_BEFORE_SAVE) {
            saveLog();
        }

        Log currentEvent = new Log(eventType, messageForUser, furtherInfo);
        if (haveLoggingFile || observers.isEmpty()) {
            events.add(currentEvent);
        }

        // If error, record that error has occurred
        if (eventType.equals(EventType.ERROR) || eventType.equals(EventType.FATAL_ERROR)) {
            errorRecorded = true;
        }

        // Inform observers
        if (!observers.isEmpty()) {
            if (!haveLoggingFile && !events.isEmpty()) {
                for (Log event : events) {
                    notifyObservers(event.type, event.toString());
                }
                events.clear();
            }
            notifyObservers(eventType, (haveLoggingFile ? messageForUser : currentEvent.toString()));
        }
    }

    /**
     * Registers (adds) the given {@link LoggerObserver} to the observers that this
     * {@link EventLogger} informs of events.
     *
     * @param observer the observer to add
     * @return whether the given observer was registered successfully with this {@link EventLogger}
     */
    public boolean registerObserver(LoggerObserver observer) {
        return observers.add(observer);
    }

    /**
     * Removes the given {@link LoggerObserver} from the observers that this {@link EventLogger}
     * informs of events.
     *
     * @param observer the observer to remove
     * @return whether the given observer was removed successfully from this {@link EventLogger}
     */
    public boolean removeObserver(LoggerObserver observer) {
        return observers.remove(observer);
    }

    private File getLogFile(String name) {
        int logNum = 1;
        String logName;
        File logFile;
        boolean fileExists;
        do { // Don't write to file over 500kB
            logName = name + "[" + logNum + "].log";
            logFile = new File(logName);
            logNum++;

            fileExists = logFile.exists();
        } while (fileExists && (logFile.length() > 512000L || !logFile.canWrite()));

        // Try to make the file if it doesn't yet exist.
        if (!fileExists) {
            try {
                if (!logFile.createNewFile()) {
                    Nepic.log(EventType.ERROR, "Attempt to create new log file "
                            + logFile.getName() + " has failed.");
                    return null;
                }
            } catch (IOException e) {
                Nepic.log(EventType.ERROR,
                        "Exception occurred while trying to create new log file "
                                + logFile.getName(), formatException(e));
                return null;
            }
        }

        return logFile;
    }

    private String makeStartingLogLine() {
        return new StringBuilder("\n\n*****************************************************\n\n# ")
                .append(Nepic.getName())
                .append(' ')
                .append(Nepic.getFullVersion())
                .append(" ")
                .append(this.getClass().getName())
                .append(" initialized ")
                .append(new Date())
                .toString();
    }

    private void notifyObservers(EventType type, String message) {
        for (LoggerObserver observer : observers) { // Don't notify of VERBOSE messages.
            if (type.equals(EventType.INFO)) {
                observer.respondToInfo(message);
            } else if (type.equals(EventType.WARNING)) {
                observer.respondToWarning(message);
            } else if (type.equals(EventType.ERROR)) {
                observer.respondToError(message);
            } else if (type.equals(EventType.FATAL_ERROR)) {
                observer.respondToFatalError(message);
            }
        }
    }

    private boolean saveLog() { // will only be called if have logging file
        try {
            for (Log event : events) {
                if (!event.type.equals(EventType.VERBOSE)
                        || Nepic.getPrefs().isVerboseEventLogged()) {
                    writer.println(event);
                }
            }
            events.clear();
            writer.flush();
            return true;
        } catch (Exception e) {
            Nepic.log(EventType.ERROR, "Unable to save logged events" + ": " + formatException(e));
            return false;
        }
    }

    /**
     * Class representing a single event that has been logged.
     *
     * @author AJ Parmidge
     */
    private class Log {
        private static final String separator = " ";
        private static final String usrMsgToken = "\"";
        private final EventType type;
        private String message;

        private Log(EventType type, String messageForUser, Object[] furtherInfo) {
            // initial verification
            Verify.notNull(type, "type");
            Verify.notNull(furtherInfo, "futher info");

            // Type of event being logged
            this.type = type;

            createLogMessage(messageForUser, furtherInfo);
        }

        private void createLogMessage(String messageForUser, Object[] furtherInfo) {
            StringBuilder builder = new StringBuilder(type.toString()).append(";\t");

            // Info about method generating message to be logged
            appendMessage(builder, beginLog());
            builder.append(" ::");

            // Include message to user, if necessary
            if (messageForUser != null && !messageForUser.isEmpty()) {
                builder.append(separator).append(usrMsgToken).append(messageForUser).append(
                        usrMsgToken);
            }

            // Include all given further info
            appendMessage(builder, furtherInfo);

            message = builder.toString();
        }

        private void appendMessage(StringBuilder messageBuilder, Object[] furtherInfo) {
            for (Object o : furtherInfo) {
                messageBuilder.append(separator).append(o);
            }
        }

        private Object[] beginLog() {
            StackTraceElement callerMethodInfo = Thread.currentThread().getStackTrace()[7];
            Object[] eventInfo = new Object[5];
            eventInfo[0] = callerMethodInfo.getClassName();
            eventInfo[1] = callerMethodInfo.getMethodName() + "()";
            eventInfo[2] = "[line";
            eventInfo[3] = callerMethodInfo.getLineNumber();
            eventInfo[4] = "]";
            return eventInfo;
        }

        @Override
        public String toString() {
            return message;
        }
    }
}
